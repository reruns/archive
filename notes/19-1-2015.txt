Lambda calculus

functions are represented by λvar.body, e.g. the identity function: λx.x

application just looks like xy, so (λx.x)y => y

Vars held by a lambda are 'bound;' those not are called 'free.'
In (λx.xy)(λy.y) y is free on the left, but bound on the right.

Functions are applied by total substitution.
Applying the identity function to itself: (λx.x)(λy.y)
The second expression is substituted into the first, leaving (λy.y).

Vars in different expressions are independent, but can have the same name. The names
don't have any meaning, so you can just change them to avoid a collision.

MATH:
We can get numbers out of Church Numerals.

Zero can be defined as λs(λz.z), a function with two arguments.
Abbreviated as λsz.z

1: λsz.s(z)
2: λsz.s(s(z))
3: λsz.s(s(s(z)))

and so on. Now that we have numbers, let's make them do things.
The simplest is the successor function:
S = λwyx.y(wyx)

(λwyx.y(wyx))(λsz.z)
yields
λyx.y((λsz.z)yx) = λyx.y((λz.z)x) = λyx.y(x) = λsz.s(z) = 1

Hot dang, it worked!

Addition follows shortly, just repeatedly apply the successor function.
2 + 3 looks like
2S3 = (λsz.s(s(z))) (λwyx.y(wyx)) (λsz.s(s(s(z))))
ultimately yields SS3 = S4 = 5

Multiplication can be done with the function
(λxyz.x(yz))
e.g.
(λxyz.x(yz))22 = (λyz.2(yz)2 = λz.2(2z) = 4

CONDITIONALS
We can use functions that take two arguments and return one to get conditionals.
T = λxy.x
F = λxy.y

And now we get logical operators

AND = λxy.xy(λuv.v) = λxy.xyF
OR = λxy.x(λuv.u)y = λxy.xTy
NOT = λx.x(λuv.v)(λab.a) = λx.xFT

e.g. NOT T is λx.x(λuv.v)(λab.a)(λcd.d)
= (λcd.d)(λuv.v)(λab.a) = (λcd.d)(λv.v) = (λvd.d) = F

And now we can make a function Z(x) s.t. Z = T for x=0 and F for x!=0
Z = λx.x F NOT F

consider:
0fa = (λsz.z)fa = a
that is, any function applied 0 times to a yields a

Also, F applied to any argument is I
Fa = (λxy.y)a = λy.y

knowing this, it's easy to see:
Z0 = 0 F NOT F = NOT F = T
ZN = N F NOT F = I F = F

Let's make a predecessor function. We want to get a pair, (n,n-1) and take the second.
Represent a pair with (λz.zab).

How do we get (n, n-1)? Well, we can't count down from n, so we gotta count up from 0.
We're gonna need a thing that counts up, and also is a pair.

let p = (n, n-1). Then, PHI = (λpz.z(S(pT))(pT)) returns (n+1, n-1)

Cool, now just let P = λn.nPHI(λz.z00)F
Note that the predecessor of 0 is 0.

And with THAT in our hands, we have the power to define >=
G = (λxy.Z(xPy))
If x >= y and y >= x, x == y, so
E = (λxy.AND(Z(xPy))(Z(yPx)))

If the predecessor applied x times to y is 0, then x > y, and the Z will be true.

RECURSION:
Now we getting real. We define recursion with a function that calls
a function y then regenerates itself. Uh, what? Consider this:

Y = (λy.(λx.y(xx))(λx.y(xx)))
YR = (λx.R(xx)(λx.R(xx))) = R((λx.R(xx))(λx.R(xx))))
that is, YR = R(YR).

So just let R be whatever your recursive call is, pass in the operators, and go.

Projects for the reader
1. Define the functions “less than” and “greater than” of two numerical arguments.
  > is just >= AND NOT <=, so
  GT = λxy.AND(Z(xPy))(NOT Z(yPx))
  LT = λxy.AND(NOT (xPy))(Z(yPx))

2. Define the positive and negative integers using pairs of natural numbers.
3. Define addition and subtraction of integers.
4. Define the division of positive integers recursively.
5. Define the function n! = n · (n − 1)· · · 1 recursively.
6. Define the rational numbers as pairs of integers.
7. Define functions for the addition, subtraction, multiplication and division of
rationals.
8. Define a data structure to represent a list of numbers.
9. Define a function which extracts the first element from a list.
10. Define a recursive function which counts the number of elements in a list.
11. Can you simulate a Turing machine using λ calculus?



--------
fix (\g x -> if x < 10 then x else g (fix (\f n -> if n < 10 then n else (f(div n 10) + (mod n 10))) x))

1.Array Pair Sum
aps :: [Int] -> int -> [(Int, Int)]

\xs n = [(x,y) | x <- xs, y <- xs, x + y == n]

2. Matrix Region Sum
If we can convince them to give us the data in vectors, then something like

mrs :: Vector (Vector Int) -> (Int,Int) -> (Int, Int) -> Int
mrx xs a b =
  let left = min (first a) (first b)
  let right = max (first a) (first b)
  let top = max (last a) (last b)
  let bottom = min (last a) (last b)
  sum [xs !! x !! y | x,y <- Int, y > bottom, y > top, x < right, x > left]
